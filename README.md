# GOGREEN Galaxy Cluster Research
## Advisor: Gregory Rudnick
### KU Galaxy Evolution Group
### Spring 2022

***

## The GOGREEN Class

The motivation behind this class was to automate plot generation and access to GOGREEN cluster data. A single plot requires extracting members associated with some cluster, reducing the set of members to only those that meet some specified criteria, then plotting the results. The class strives to encapsulate commonly used routines for extracting desired data from the GOGREEN catalogs into an easy to use object that handles most of the work behind the scenes. The accompanying Jupyter Notebook "myDataAnalysis.ipynb" has a thorough explaination of the class, its members and methods, as well as provides some sample usage and example plots. It is this plot() method that is the primary reason for creating the GOGREEN class in the first place. Having manually generated multiple plots, it became obvious that many aspects of the process remain static and the few parameters that do change could be automated. With that in mind, the goal of plot() was to pass in as input the name of the quantity to plot on the x-axis, and the name of the quantity to plot on the y-axis and let the class take care of the rest. Many of the method parameters have default values that are common choices in many cases, leaving customization options available to the user.

With that being said, I attempted to write the class in a way that is extendable and able to adapt for specific use cases. One could add new methods that apply different constraints to the data, much in the same way getMembers() reduces a larger DataFrame into one containing only spectroscopic or photometic members. While this is fine for "outside the class" plotting or analysis, if the class is to plot it using its plot() method, one must therefore modify that method too.

### Plot Method Adaptations/Improvements

If the plot() method is to be extended, it is worth some time to talk about how the code is structured and where things could be changed. 

The primary structure of the method consists of nested if-else blocks where the outer block checks the value of plotType and the inner block checks the value of colorType. Note plotTypes 1 and 3 are similar in the sense they both only generate a single plot and plotTypes 2 and 3 are similar in the sense they both loop over every cluster in the catalog. While an "elegent" solution would contain at most a single loop through the list of clusters, juggling various plotType and colorType combinations would make the method terribly difficult to read. It is in light of this that the method was designed using nested if-else blocks, even though it involves the repeated reuse of code. 

In fact, because of this KISS (Keep It Simple Stupid) design, adaptations/extensions are far more feasible. To add a different plotType, one would need to add a new block to the outer if-else statement. Assuming no modifications have been made, this would go after "elif plotType == 3" but before the closing else. Within this new plotType, a new colorType if-else block would need to be constructed to maintain use with the already implemented "membership" or "passive" values. This could simply involve copying the inner if-else block from plotType 2 or 3 or, depending on how the new plotType is generating plots, might require minor changes.

Another adaptation could involve adding a new colorType to differentiate between sources in ways other than by the implemented "membership" or "passive". The if-else structure of the method lends nicely to this as well. To add a new colorType, a new block should be added to every inner if-else block. Again assuming no changes to the original code have been made, this would be placed after "elif colorType == 'passive'". It needs to be done inside every plotType if-else block as to ensure the new colorType is accessible no matter which plotType is chosen.

For graphical appearances, many more parameters could be added to modify the configuration of the final plot(s). The code handling plot configuration is found at the end of the plotType==2 block as well as after the main plotType if-else block. The code contained in these two locations is nearly identical with the only difference being the statements contained in the plotType 2 block act on subplots. To add more control over this configuration, after adding a new parameter to specify when it should be used, add the appropriate pyplot statements to add that configuration to the plot. Again, this must be done in both plot configuration locations to maintain the robustness of the method.

Possible Improvements:
* Specify an alpha value for plotted sources
* Specify a title for plot generated by plotType 1 and 3
* Add a method to return passive vs star-forming sources (similar to how getMembers() returns spec members vs phot members)
* Have plot() return the DataFrame it used to generate the plot (for "out of class" analysis/plotting)
* Combine the Redshift catalog with the catalog member
* Add a method to generate a list of sources to circle in a DS9 image
* Add a method to fit the data generated by plot()
* Have plot() save the generated figures